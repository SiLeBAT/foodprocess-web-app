/**
 *   This file declares and exports the view for the settings. The declaration contains all data bindings and events for the view.
 */

let $ = require('jquery');
let joint = require('jointjs/dist/joint.js');
let Backbone = require('backbone');
let moment = require('moment');
let _ = require('lodash');

import {AdditionalMetadataModel, AdditionalMetadataCollection} from '../models/index.jsx';

let settingsTemplate = require('../../templates/settings.html');
let metadataTemplate = require('../../templates/metadata.html');

let metadataNamesCV = require('../../cv/metadata.csv');

export let SettingsView = Backbone.View.extend({
    template: _.template(settingsTemplate),
    metadataTemplate: _.template(metadataTemplate),
    // Bind the content of the input fields to the model
    bindings: {
        '#settingsWorkflowNameInput': 'workflowName',
        '#settingsAuthorInput': 'author',
        '#settingsReferenceInput': 'reference',
        '#settingsDescriptionInput': 'description',
        '#settingsCreated': {
            observe: 'created',
            onGet: 'formatDate'
        },
        '#settingsLastChange': {
            observe: 'lastChanged',
            onGet: 'formatDate'
        }
    },
    // Bind events to appropriate functions
    events: {},
    listenerAdded: false,
    initialize: function(model, workspaceGraph) {
        this.model = model;
        this.workspaceGraph = workspaceGraph;

        this.metadataNames = metadataNamesCV.sort(this.compareByName);

        // Set the dates of creation and last change
        !this.model.get('created') && this.model.set('created', new Date());
        !this.model.get('lastChanged') && this.model.set('lastChanged', new Date());

        // Listen to changes and update the date of the last change
        let self = this;
        this.workspaceGraph.on('add remove change', function() {
            self.updateLastChanged();
        });
        this.model.on('change', function() {
            if (self.model.changedAttributes().hasOwnProperty('lastChanged')) {
                return;
            }
            self.updateLastChanged();
        });
        // Trigger workspace change event to update "lastChanged"
        this.model.get('metadata').on('change', function() {
            self.workspaceGraph.trigger('change');
        });
    },
    render: function() {
        let settingsModalSelector = '.reveal-overlay > #settingsModal';
        // Remove the old settings modal
        $(settingsModalSelector).parent().remove();
        this.$el.html(this.template({model: this.model}));
        if (!this.listenerAdded) {
            this.addMetadataButtonListener();
            // this.createListenerForSettingSynchronisation();
            this.renderMetadataSection();
            this.$el.foundation();
            // Set element to the generated settings root element (generated by foundation)
            this.$el = $(settingsModalSelector).parent();
            this.stickit();
            this.listenerAdded = true;
        }
    },
    // Format date
    formatDate: function(date) {
        return moment(date).format('DD.MM.YYYY HH:mm');
    },
    updateLastChanged: function() {
        this.model.set('lastChanged', new Date());
    },
    // Add a key value pair to the metadata
    addMetadataButtonListener: function() {
        let self = this;
        this.$el.find('#addMetadataButton').on('click', function() {
            self.addAdditionalMetadata();
        });
    },
    // Re-render the metadata section and re-create the bindings
    renderMetadataSection: function() {
        // Re-render the metadata section
        this.$el.find('#metadataSection').html(this.metadataTemplate({model: this.model, metadataNames: this.metadataNames}));
        // Add bindings for all metadata inputs for data synchronization
        this.addMetadataBindings();
        // Scroll to bottom if the settings view is higher than the viewport
        this.$el.scrollTop(this.$el.children(':first').height());
    },
    addMetadataBindings: function() {
        let additionalMetadata = this.model.get('metadata').models;
        let self = this;
        _.each(additionalMetadata, function (metadataModel) {
            let metadataId = metadataModel.get('id');
            let bindings = {
                key: '#metadataKeySelect' + metadataId,
                value: '#metadataValueInput' + metadataId
            };
            let binder = new Backbone.ModelBinder(); // needs to be a new instance for each "bindings"!
            binder.bind(metadataModel, self.$el, bindings);
            // Add a click listener for the remove button
            self.$el.find('#removeMetadata' + metadataId).on('click', function() {
                // Remove the metadata
                self.model.get('metadata').remove(metadataId);
                // Re-render the section
                self.renderMetadataSection();
            });
        });
    },
    addAdditionalMetadata: function() {
        let metadataCollection = this.model.get('metadata');
        let idString = "Metadata";
        let idNumber = 0;
        if (metadataCollection.size()) {
            idNumber = parseInt(metadataCollection.at(metadataCollection.size() - 1).get('id').replace(idString, '')) + 1;
        }
        metadataCollection.add(new AdditionalMetadataModel({
            id: idString + idNumber
        }));
        this.renderMetadataSection();
    },
    // Compare elements by name for sorting
    compareByName: function(a, b) {
        let nameA = a.name.toLowerCase();
        let nameB = b.name.toLowerCase();
        if (nameA < nameB)
            return -1;
        if (nameA > nameB)
            return 1;
        return 0;
    }
});